import { IAuthor, IAuthorNormalized, IPostNormalized } from '../types/base'
import { DebuggableAPI, cryptoRandomId } from '../types/debug'

class MyDexie extends window.Dexie {
  /**
   * * version 4: ^0.2.8
   */
  static version = 4;
  static dbname = 'aloud-comments';

  public authors: Dexie.Table<IAuthorNormalized, string>;
  public posts: Dexie.Table<IPostNormalized, string>;

  static async create () {
    try {
      const tempDb = await new window.Dexie(MyDexie.dbname).open()
      if (tempDb.verno < MyDexie.version) await tempDb.delete()
      tempDb.close()
    } catch (_) {}

    return new MyDexie()
  }

  private constructor () {
    super(MyDexie.dbname)

    this.version(MyDexie.version).stores({
      authors: 'id',
      posts: 'id, [parentId+url], parentId, url, createdAt'
    })

    this.authors = this.table('authors')
    this.posts = this.table('posts')
  }
}

export class DexieAPI extends DebuggableAPI {
  private db!: MyDexie;

  /**
   * Be careful when using this first autogenerated Author
   */
  firstAuthor: IAuthor;

  /**
   *
   * @override
   */
  async populateDebug (urls: string[], maxAuthorCount = 6): Promise<void> {
    this.db = await MyDexie.create()

    await super.populateDebug(urls, maxAuthorCount)
    this.firstAuthor = await this.getAuthor(this.authorIds[0])
  }

  async getAuthorIds (): Promise<string[]> {
    const keys: string[] = []

    await this.db.authors
      .filter(() => true)
      .eachPrimaryKey(k => {
        keys.push(k)
      })

    return keys
  }

  async addAuthor (
    a: Omit<IAuthorNormalized, 'id'> & { id?: string }
  ): Promise<IAuthorNormalized> {
    const r = await this.db.authors.add({
      ...a,
      id: cryptoRandomId()
    })

    return {
      ...a,
      id: r
    }
  }

  async getAuthor (id: string): Promise<IAuthorNormalized | null> {
    return this.db.authors.get(id)
  }

  async addPost (
    a: Omit<IPostNormalized, 'id'> & { id?: string }
  ): Promise<IPostNormalized> {
    const r = await this.db.posts.add({
      ...a,
      id: cryptoRandomId()
    })

    return {
      ...a,
      id: r
    }
  }

  async getPost (id: string): Promise<IPostNormalized | null> {
    return this.db.posts.get(id)
  }

  async findPosts (
    p: Partial<IPostNormalized>,
    {
      after,
      limit = 3
    }: {
      after?: string;
      limit: number;
    }
  ): Promise<{
    result: IPostNormalized[];
    hasMore: boolean;
  }> {
    if (!this.db) {
      return {
        result: [],
        hasMore: true
      }
    }

    let out = await this.db.posts.where(p).reverse().sortBy('createdAt')

    const i = after ? out.map(({ id }) => id).indexOf(after) : -1
    if (i !== -1) {
      out = out.slice(i + 1)
    }

    return {
      hasMore: out.length > limit,
      result: out.slice(0, limit)
    }
  }

  async countPosts (p: Partial<IPostNormalized>): Promise<number> {
    return this.db.posts.where(p).count()
  }

  async updatePost (
    id: string,
    p: Partial<Omit<IPostNormalized, 'id'>>
  ): Promise<boolean> {
    const r = await this.db.posts.update(id, p)
    return !!r
  }

  async deletePost (id: string): Promise<boolean> {
    const r = await this.db.posts.where('id').equals(id).delete()
    return !!r
  }
}
